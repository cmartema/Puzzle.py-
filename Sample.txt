  """A * search"""
    ### STUDENT CODE GOES HERE ###
    frontier = []
    frontier_config = set()
    frontier.append((initial_state, 0))
    frontier_config.add(tuple(initial_state.config))
    explored = set()
    max_depth = 0
    nodes_expanded = 0

    while frontier:
       
        state_depth = frontier.pop(0)#state with lowest estimated cost
        state = state_depth[0]
        curr_depth = state_depth[1]
         #sort by cost in acending order. pop provides the mininmum state (equivalent to a heap)
         #Sort the frontier based on the total estimated cost f(n)
        frontier.sort(key=lambda state: calculate_total_cost(state_depth[0])) 

        
        explored.add(tuple(state.config))

        if test_goal(state) == True:
            return state, max_depth, nodes_expanded
        
        child = state.expand()
        nodes_expanded += 1
        for neighbor in child:
            neighbor_config = tuple(neighbor.config)
            if neighbor_config not in frontier_config and neighbor_config not in explored:
                frontier.append((neighbor, curr_depth + 1))
                frontier_config.add(neighbor_config)
                max_depth = max(max_depth, curr_depth + 1)

            elif neighbor_config in frontier:
                #Find the existing state in frontier with the same configuration
                #Compare the total cost of the existing state and the new neighbor
                #Replace the existing state with the new neighbor
                existing_state = next(s for s in frontier if tuple(s.config) == neighbor_config)
                if calculate_total_cost(neighbor) < calculate_total_cost(existing_state):
                    frontier.remove(existing_state)
                    frontier.append((neighbor, curr_depth + 1))
                    frontier_config.add(neighbor_config)
                    max_depth = max(max_depth, curr_depth + 1)
    return None









      """A * search"""
    ### STUDENT CODE GOES HERE ###
    frontier = Q.PriorityQueue()
    frontier.put((initial_state, initial_state.cost+calculate_total_cost(initial_state), 0)) #(state, cost, depth)
    frontier_config = set()
    frontier_config.add(tuple(initial_state.config))
    explored = set()
    explored_config = set()
    max_depth = 0
    nodes_expanded = 0

    while not frontier.empty():
        state_cost_depth = frontier.get()
        state = state_cost_depth[0]
        state_cost = state_cost_depth[1]
        curr_depth = state_cost_depth[2]

        explored.add(state_cost_depth)
        explored_config.add(tuple(state.config))

        if test_goal(state) == True:
            return state, nodes_expanded, max_depth
        
        child = state.expand()
        nodes_expanded += 1
        for neighbor in child:
            neighbor_config = tuple(neighbor.config)
            if neighbor_config not in frontier_config and neighbor_config not in explored_config:
                frontier.put((neighbor, neighbor.cost + calculate_total_cost(neighbor), curr_depth + 1))
                frontier_config.add(neighbor_config)
                max_depth = max(max_depth, curr_depth + 1)
            elif neighbor_config in frontier_config:
                
                #decreases the key
                for idx in frontier.queue:
                    if idx[0].config == neighbor.config:
                        existing_priority = idx[1]
                        new_priority = neighbor.cost + calculate_total_cost(neighbor)
                        new_depth = idx[2]

                        # If the new priority is lower, update the priority queue
                        if new_priority < existing_priority:
                            frontier.queue.remove(idx)
                            frontier.put((neighbor, new_priority, new_depth - 1))